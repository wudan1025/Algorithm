/*
 * @LastEditors: wudan01
 * @description: 文件描述
 */

/*
在认识优先队列之前，我们先来看一道题：

题目描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5

示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4

说明:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
*/

/*
期望不在对所有元素都排序的情况下，定位到第K个元素 - 构建一个堆结构

维护大小为 k 的小顶堆的目的，是为了确保堆中除了堆顶元素之外的 k-1 个元素值都大于堆顶元素。
当我们用数组的[0, k-1]区间里的 数字初始化完成这个堆时，堆顶元素值就对应着前 k 个数字里的最小值。
紧接着我们尝试用索引区间为 [k, n-1]的数字来更新堆，
在这个过程中，只允许比堆顶元素大的值进入堆。
这一波操作过后，堆里的 k 个数字就是整个数组中最大的 k 个数字，
而堆顶的数字正是这 k 个数中最小的那个。于是本题得解。
 */

/*
总结
优先队列的本质是二叉堆结构，它具有以下特性：
队列的头部元素，也即索引为0的元素，就是整个数组里的最值——最大值或者最小值
对于索引为 i 的元素来说，它的父结点下标是 (i-1)/2（上面咱们讲过了，这与完全二叉树的结构特性有关）
对于索引为 i 的元素来说，它的左孩子下标应为2*i+1，右孩子下标应为2*i+2。
当题目中出现类似于“第k大”或者“第k高“这样的关键字时，
就是在暗示你用优先队列/堆结构来做题——这样的手法可以允许我们在不对序列进行完全排序的情况下，找到第 k 个最值。
*/

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
const findKthLargest = function (nums, k) {
  // 初始化一个堆数组
  const heap = [];
  // n表示堆数组里当前最后一个元素的索引
  let n = 0;
  // 缓存 nums 的长度
  const len = nums.length;
  // 初始化大小为 k 的堆
  function createHeap() {
    for (let i = 0; i < k; i++) {
      // 逐个往堆里插入数组中的数字
      insert(nums[i]);
    }
  }

  // 尝试用 [k, n-1] 区间的元素更新堆
  function updateHeap() {
    for (let i = k; i < len; i++) {
      // 只有比堆顶元素大的才有资格进堆
      if (nums[i] > heap[0]) {
        // 用较大数字替换堆顶数字
        heap[0] = nums[i];
        // 重复向下对比+交换的逻辑
        downHeap(0, k);
      }
    }
  }

  // 向下对比函数
  function downHeap(low, high) {
    // 入参是堆元素在数组里的索引范围，low表示下界，high表示上界
    let i = low,
      j = i * 2 + 1;
    // 当 j 不超过上界时，重复向下对比+交换的操作
    while (j <= high) {
      // // 如果右孩子比左孩子更小，则用右孩子和根结点比较
      if (j + 1 <= high && heap[j + 1] < heap[j]) {
        j = j + 1;
      }

      // 若当前结点比孩子结点大，则交换两者的位置，把较小的结点“拱上去”
      if (heap[i] > heap[j]) {
        // 交换位置
        const temp = heap[j];
        heap[j] = heap[i];
        heap[i] = temp;

        // i 更新为被交换的孩子结点的索引
        i = j;
        // j 更新为孩子结点的左孩子的索引
        j = j * 2 + 1;
      } else {
        break;
      }
    }
  }

  // 入参是堆元素在数组里的索引范围，low表示下界，high表示上界
  function upHeap(low, high) {
    // 初始化 i（当前结点索引）为上界
    let i = high;
    // 初始化 j 为 i 的父结点
    let j = Math.floor((i - 1) / 2);
    // 当 j 不逾越下界时，重复向上对比+交换的过程
    while (j >= low) {
      // 若当前结点比父结点小
      if (heap[j] > heap[i]) {
        // 交换当前结点与父结点，保持父结点是较小的一个
        const temp = heap[j];
        heap[j] = heap[i];
        heap[i] = temp;

        // i更新为被交换父结点的位置
        i = j;
        // j更新为父结点的父结点
        j = Math.floor((i - 1) / 2);
      } else {
        break;
      }
    }
  }

  // 插入操作=将元素添加到堆尾部+向上调整元素的位置
  function insert(x) {
    heap[n] = x;
    upHeap(0, n);
    n++;
  }

  // 调用createHeap初始化元素个数为k的队
  createHeap();
  // 调用updateHeap更新堆的内容，确保最后堆里保留的是最大的k个元素
  updateHeap();
  // 最后堆顶留下的就是最大的k个元素中最小的那个，也就是第k大的元素
  return heap[0];
};
